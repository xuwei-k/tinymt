package jp.ac.hiroshima_u.sci.math.saito.tinymt;

import java.io.IOException;
import java.math.BigInteger;

import org.apache.commons.math.random.AbstractRandomGenerator;
/**
 * TinyMT64 is a pseudo random number generator.
 * <p>
 * To get an instance, call {@link TinyMT64#getDefault(long)}.
 *</p>
 *<p>
 * This class is not synchronized, One way to use TinyMT64 in concurrent
 * environment is to use an instance per a thread.
 * </p>
 * <p>
 * This class supports jump function.
 * User can get an array of pseudo random number generators by calling
 * {@link TinyMT64#getDefaultArray(int, long, long)},
 * or {@link TinyMT64#getDefaultArray(int, String, long)}.
 * </p>
 * <p>
 * This class supports discrete characteristic polynomial generators.
 * User can get an array of pseudo random number generators whose characteristic
 * polynomials are discrete by calling
 * {@link TinyMT64#getTinyMTArray(int, long)}. 
 * </p>
 * @author M. Saito
 * @see
 *  <a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/TINYMT/index.html">
 *  TinyMT web page</a>
 */
public final class TinyMT64 extends AbstractRandomGenerator {
    /** bit size of int. */
    private static final int INT_SIZE = 32;
    /** initialize shift. */
    private static final int INITIALIZE_SHIFT = 59;
    /** initialize shift. */
    private static final int INITIALIZE_SHIFT2 = 62;
    /** magic number. */
    private static final long MAGIC_NUMBER1 = 2173292883993L;
    /** magic number. */
    private static final long MAGIC_NUMBER2 = 58885565329898161L;
    /** magic number. */
    private static final long MAGIC_NUMBER3 = 6364136223846793005L;
    /** long to double shift. */
    private static final int LONG_TO_DOUBLE_SHIFT = 12;
    /** basic jump step.
     * every jump step is a multiple of this step.
     */
    private static final BigInteger BASIC_JUMP_STEP 
        = new BigInteger("2").pow(64);
    /** mask pattern to limit internal size. */
    private static final long MASK = 0x7fffffffffffffffL;
    /** fixed shift 0. */
	private static final int SH0 = 12;
    /** fixed shift 1. */
	private static final int SH1 = 11;
    /** fixed 8 bit shift. */
	private static final int SH8 = 8;
    /** minimum loop for initialization. */
    private static final int MIN_LOOP = 8;
    /** internal state 0. */
	private long st0;
    /** internal state 1. */
	private long st1;
    /** parameters for this generator. */
	private final TinyMT64Parameter parameter;

	/**
	 * Constructor from a parameter.
	 * @param pparameter a parameter generated by TinyMTDC
	 */
	private TinyMT64(final TinyMT64Parameter pparameter) {
		this.parameter = pparameter;
	}
	
	/**
	 * Copy constructor.
	 * This is needed by the jump.
	 * @param that source
	 */
	private TinyMT64(final TinyMT64 that) {
		this.parameter = that.parameter;
		this.st0 = that.st0;
		this.st1 = that.st1;
	}

	/**
	 * returns 32-bit integer.
	 * @return next int
	 */
	@Override
	public int nextInt() {
	    nextState();
	    return (int) (output() >>> INT_SIZE);
	}

	/**
	 * returns 64-bit integer.
	 * @return next long
	 */
    @Override
	public long nextLong() {
        nextState();
        return output();
	}
	
	/**
	 * seeding by string, This will be convenient.
	 * This function does not compatible from other language
	 * implementation because coding of characters are different.
	 * @param seed seed of pseudo random numbers
	 */
	public void setSeed(final String seed) {
		long[] intSeeds = new long[seed.length()];
		for (int i = 0; i < intSeeds.length; i++) {
			intSeeds[i] = seed.charAt(i);
		}
		setSeed(intSeeds);
	}
	
	/**
	 * Seeding by array of long.
	 * This seeding is compatible with other language implementation.
	 * @param seeds seeds of pseudo random numbers.
	 */
	public void setSeed(final long[] seeds) {
//  Needed if this is a subclass of java.util.Random. (Before Java 7)
//      
//    if (parameter == null) {
//        return;
//    }
	    final int lag = 1;
	    final int mid = 1;
	    final int size = 4;
	    int i, j;
	    int count;
	    long r;
	    int keyLength = seeds.length;
	 	long[] status = new long[4];
	    status[0] = 0;
	    status[1] = parameter.getMat1();
	    status[2] = parameter.getMat2();
	    status[3] = parameter.getTmat();
	    if (keyLength + 1 > MIN_LOOP) {
	        count = keyLength + 1;
	    } else {
	        count = MIN_LOOP;
	    }
	    r = iniFunc1(status[0] ^ status[mid % size]
	                  ^ status[(size - 1) % size]);
	    status[mid % size] += r;
	    r += keyLength;
	    status[(mid + lag) % size] += r;
	    status[0] = r;
	    count--;
	    for (i = 1, j = 0; (j < count) && (j < keyLength); j++) {
	        r = iniFunc1(status[i % size] 
	                ^ status[(i + mid) % size] ^ status[(i + size - 1) % size]);
	        status[(i + mid) % size] += r;
	        r += seeds[j] + i;
	        status[(i + mid + lag) % size] += r;
	        status[i % size] = r;
	        i = (i + 1) % size;
	    }
	    for (; j < count; j++) {
	        r = iniFunc1(status[i % size] 
	                ^ status[(i + mid) % size] ^ status[(i + size - 1) % size]);
	        status[(i + mid) % size] += r;
	        r += i;
	        status[(i + mid + lag) % size] += r;
	        status[i % size] = r;
	        i = (i + 1) % size;
	    }
	    for (j = 0; j < size; j++) {
	        r = iniFunc2(status[i % size] 
	                + status[(i + mid) % size] + status[(i + size - 1) % size]);
	        status[(i + mid) % size] ^= r;
	        r -= i;
	        status[(i + mid + lag) % size] ^= r;
	        status[i % size] = r;
	        i = (i + 1) % size;
	    }
	    st0 = status[0] ^ status[1];
	    st1 = status[2] ^ status[3];
	    periodCertification();
	    clear();
	}
	
	/**
	 * initialize internal state.
	 * @param seeds seeds of randomness
	 */
    @Override
	public void setSeed(final int[] seeds) {
	    long[] array = new long[seeds.length];
	    for (int i = 0; i < seeds.length; i++) {
	        array[i] = seeds[i];
	    }
	    setSeed(array);
	}
    
	/**
	 * Sub function for initialization.
	 * @param x input number
	 * @return scrambled integer
	 */
	private long iniFunc1(final long x) {
	    return (x ^ (x >>> INITIALIZE_SHIFT)) * MAGIC_NUMBER1;
	}
	
	/**
	 * Sub function of initialization.
	 * @param x input number
	 * @return scrambled integer
	 */
	private long iniFunc2(final long x) {
	    return (x ^ (x >>> INITIALIZE_SHIFT)) * MAGIC_NUMBER2;
	}

	/**
     * initialize internal state.
     * @param seed seeds of randomness
	 */
    @Override
	public void setSeed(final long seed) {
		long[] status = new long[2];
	    status[0] = seed ^ (parameter.getMat1() << INT_SIZE);
	    status[1] = parameter.getMat2() ^ parameter.getTmat();
	    for (int i = 1; i < MIN_LOOP; i++) {
	        status[i & 1] ^= i + MAGIC_NUMBER3
	            * (status[(i - 1) & 1]
	               ^ (status[(i - 1) & 1] >>> INITIALIZE_SHIFT2));
	    }
	    st0 = status[0];
	    st1 = status[1];
	    periodCertification();
	    clear();
	}

	/**
	 * Avoiding all zero status is enough to certificate the period of
	 *  2<sup>127</sup> - 1 for TinyMT.
	 */
	private void periodCertification() {
		if (((st0 & MASK) == 0) && (st1 == 0)) {
			st0 = 'T';
			st1 = 'M';
			}
	}

	/**
	 * The state transition function.
	 * This function is F<sub>2</sub>-linear.
	 */
	private void nextState() {
		long x;
		st0 &= MASK;
		x = st0 ^ st1;
		x ^= x << SH0;
		x ^= x >>> INT_SIZE;
        x ^= x << INT_SIZE;
        x ^= x << SH1;
		st0 = st1;
		st1 = x;
		st0 ^= parameter.getMat1(x);
		st1 ^= parameter.getMat2(x) << INT_SIZE;
	}

	/**
	 * The output function.
	 * This function is not F<sub>2</sub>-linear.
	 * @return pseudo random number
	 */
	private long output() {
		long x;
		x = st0 + st1;
		x ^= st0 >>> SH8;
		x ^= parameter.getTmat(x);
		return x;
	}

    /**
     * The output function.
     * @return pseudo random number in double.
     */
    private double outputDouble() {
        long x;
        x = st0 + st1;
        x ^= st0 >>> SH8;
        x = (x >>> LONG_TO_DOUBLE_SHIFT) ^ parameter.getTmatDouble(x);
        return Double.longBitsToDouble(x) - 1.0;
    }

	/**
	 * Addition as F<sub>2</sub> vector
	 * This function is needed for the jump.
	 * @param that vector which added to this vector
	 */
	private void add(final TinyMT64 that) {
		this.st0 ^= that.st0;
		this.st1 ^= that.st1;
	}
	
	/**
	 * Factory method which returns the TinyMT 
	 * with the first generated parameter of
	 * TinyMTDC.
	 * @param seed seed of pseudo random numbers.
	 * @return TinyMT with the first parameter.
	 */
	public static TinyMT64 getDefault(final String seed) {
		TinyMT64 tiny 
		    = new TinyMT64(TinyMT64Parameter.getDefaultParameter());
		tiny.setSeed(seed);
		return tiny;
	}
	
	/**
	 * Factory method which returns the TinyMT 
	 * with the first generated parameter of
	 * TinyMTDC.
	 * @param seed seed of pseudo random numbers.
	 * @return TinyMT with the first parameter.
	 */
	public static TinyMT64 getDefault(final long seed) {
		TinyMT64 tiny 
		    = new TinyMT64(TinyMT64Parameter.getDefaultParameter());
		tiny.setSeed(seed);
		return tiny;
	}

    /**
     * get default TinyMT32 with seeding by array.
     * @param seeds seeds for initialization.
     * @return random number generator TinyMT32
     */
    public static TinyMT64 getDefault(final int[] seeds) {
        TinyMT64Parameter defaultParameter = TinyMT64Parameter
                .getDefaultParameter();
        TinyMT64 tiny = new TinyMT64(defaultParameter);
        tiny.setSeed(seeds);
        return tiny;
    }
    
	/**
	 * Factory method which returns the TinyMT 
	 * with the first generated parameter of
	 * TinyMTDC.
	 * {@link System#nanoTime()} and {@link Thread#getId()} are used
	 * for seed.
	 * @return TinyMT with the first parameter.
	 */
	public static TinyMT64 getDefault() {
		long[] seed = new long[2];
		long time = System.nanoTime();
		long threadId = Thread.currentThread().getId();
		seed[0] = time;
		seed[1] = threadId;
		TinyMT64 tiny 
		    = new TinyMT64(TinyMT64Parameter.getDefaultParameter());
		tiny.setSeed(seed);
		return tiny;
	}
	
	/**
	 * The jump function.
	 * @param pol jump polynomial
	 * @return jumped new TinyMT
	 */
	private TinyMT64 jump(final F2Polynomial pol) {
		TinyMT64 src = new TinyMT64(this);
		TinyMT64 that = getZero();
		int degree = pol.degree();
		for (int i = 0; i <= degree; i++) {
			if (pol.getCoefficient(i) == 1) {
				that.add(src);
			}
			src.nextState();
		}
		return that;
	}
	
	/**
	 * Make and return all zero status
	 * This function is needed by the jump function.
	 * @return all zero status
	 */
	private TinyMT64 getZero() {
		TinyMT64 that = new TinyMT64(this);
		that.st0 = 0;
		that.st1 = 0;
		return that;
	}

	/**
	 * make and return an array of TinyMT.
	 * Each element has the same characteristic polynomial with TinyMT gotten by
	 * getDefaultMT. Especially, the first element is just same as 
	 * default TinyMT.
	 * The second element has the state of <b>jump</b> * 2<sup>64</sup> steps
	 * after the first element. In other word, the first element will generate
	 * the same sequence with the second element, after <b>jump</b>
	 * * 2<sup>64</sup> pseudo random number generation.
	 * @param count number of TinyMT to be created.
	 * @param seed seed of first element
	 * @param jump step is jump * 2<sup>64</sup>
	 * @return array of TinyMT
	 */
	public static TinyMT64[] getDefaultArray(final int count,
	            final long seed, final long jump) {
		TinyMT64 tiny = getDefault(seed);
		return tiny.getJumpedArray(count, jump);
	}
	
	/**
	 * Make and return an array of TinyMT.
	 * Each element has the same characteristic polynomial with TinyMT gotten by
	 * getDefaultMT. Especially, the first element is just same as
	 * default TinyMT.
	 * The second element has the state of <b>jump</b> * 2<sup>64</sup> steps
	 * after the first element. In other word, the first element will generate
	 * the same sequence with the second element, after <b>jump</b>
	 * * 2<sup>64</sup> pseudo random number generation.
	 * @param count number of TinyMT to be created.
	 * @param seed seed of first element
	 * @param jump step is jump * 2<sup>64</sup>
	 * @return array of TinyMT
	 */
	public static TinyMT64[] getDefaultArray(final int count,
	            final String seed, final long jump) {
		TinyMT64 tiny = getDefault(seed);
		return tiny.getJumpedArray(count, jump);
	}
	
	/**
	 * Make and return an array of TinyMT.
	 * Each element of the array has the same characteristic polynomial with
	 * this.
	 * Especially, the first element is just same as this.
	 * The second element has the state of <b>jump</b> * 2<sup>64</sup> steps
	 * after the first element. In other word, the first element will generate
	 * the same sequence with the second element, after <b>jump</b>
	 * * 2<sup>64</sup> pseudo random number generation.
	 * @param count number of arrays 
	 * @param jump jump step
	 * @return jumped array of TinyMT64.
	 */
	public TinyMT64[] getJumpedArray(final int count, final long jump) {
		TinyMT64[] tiny = new TinyMT64[count];
		tiny[0] = new TinyMT64(this);
		final F2Polynomial poly = tiny[0].parameter.getCharacteristic();
		final BigInteger pow 
		    = BASIC_JUMP_STEP.multiply(new BigInteger(Long.toString(jump)));
		final F2Polynomial jumpPoly = F2Polynomial.X.powerMod(pow, poly);
		for (int i = 1; i < count; i++) {
			tiny[i] = tiny[i - 1].jump(jumpPoly);
		}
		return tiny;
	}
	
	/**
	 * Make and return an array of TinyMT.
	 * Each element of the array has discrete characteristic polynomial.
	 * This function does not return defaultTinyMT.
	 * User can call {@link TinyMT64#getJumpedArray(int, long)}
	 * using each element and can get more TinyMTs.
	 * @param count number of TinyMT to be created.
	 * @param seed seed of each element
	 * @return array of TinyMT
	 * @throws IOException when can't read resource file.
	 */
	public static TinyMT64[] getTinyMTArray(final int count, final long seed)
	            throws IOException {
		TinyMT64Parameter[] params = TinyMT64Parameter.getParameters(count);
		TinyMT64[] tiny = new TinyMT64[count];
		for (int i = 0; i < count; i++) {
			tiny[i] = new TinyMT64(params[i]);
			tiny[i].setSeed(seed);
		}
		return tiny;
	}

	/**
     * returns double r, 0 <= r < 1.0.
     * @return next double 
     */
    @Override
	public double nextDouble() {
	    nextState();
		return outputDouble();
	}

    /**
     * returns float r, 0 <= r < 1.0.
     * @return next float
     */
    @Override
	public float nextFloat() {
		return (float) nextDouble();
	}
    
    /**
     * return ID of TinyMT.
     * ID is not unique in TinyMT.
     * @return ID
     */
    public int getId() {
        return parameter.getId();
    }
    
    /**
     * return Delta of TinyMT.
     * @return Delta
     */
    public int getDelta() {
        return parameter.getDelta();
    }
    
    /**
     * return Hamming weight of characteristic polynomial of TinyMT.
     * @return Hamming weight
     */
    public int getWeight() {
        return parameter.getWeight();
    }
}
